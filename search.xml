<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/2019/03/26/config/(theme)_config/"/>
      <url>/2019/03/26/config/(theme)_config/</url>
      <content type="html"><![CDATA[null]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/03/26/config/(main)_config/"/>
      <url>/2019/03/26/config/(main)_config/</url>
      <content type="html"><![CDATA[null]]></content>
      
      
    </entry>
    
    <entry>
      <title>梯度下降优化算法总结</title>
      <link href="/2019/03/25/gd-overview/"/>
      <url>/2019/03/25/gd-overview/</url>
      <content type="html"><![CDATA[<!-- <script type="text/javascript" src="http://cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> --><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>梯度下降（Gradient descent）在深度学习中是常用的一种优化方法，在一些机器学习框架中（caffes、keras）中也提供对于梯度下降的优化，所以在这篇博文中对这些优化方法做出总结。<a id="more"></a><br>梯度下降核心思想是通过将一个模型的参数通过向目标函数\(J(\theta)\)的反向梯度\(\nabla_\theta J(\theta)\)更新达到目标函数的最小。这个目标函数通常表示了训练数据中模型结果和实际结果的差异，通过最小化这个差异而得到最佳近似的模型。在梯度下降方法中也引入了学习速率\(\eta\)来限制下降的速度。\begin{align}<br>\begin{split}<br>\theta = \theta - \eta \cdot \nabla_\theta J( \theta)<br>\end{split}<br>\end{align}</p><h2 id="梯度下降的不同方式"><a href="#梯度下降的不同方式" class="headerlink" title="梯度下降的不同方式"></a>梯度下降的不同方式</h2><h3 id="批次梯度下降-Batch-gradient-descent"><a href="#批次梯度下降-Batch-gradient-descent" class="headerlink" title="批次梯度下降 Batch gradient descent"></a>批次梯度下降 Batch gradient descent</h3><p>传统的梯度下降方法，在每一个训练步骤epoch都对模型中的每一个参数计算梯度并进行更新，这在复杂模型中是不实际的。批次梯度下降方法可以确保在凸平面函数中得到全局最优解、在非凸平面函数中得到局部最优。  </p><h3 id="随机梯度下降-Stochastic-gradient-descent"><a href="#随机梯度下降-Stochastic-gradient-descent" class="headerlink" title="随机梯度下降 Stochastic gradient descent"></a>随机梯度下降 Stochastic gradient descent</h3><p>与批次梯度下降不同，随机梯度下降（SGD）在每一个epoch中仅对一个随机选择的参数计算梯度，由于计算参数的减少大大加快了训练的速度并且可以在线训练。但是SGD同时也在过程中引入了很大的方差使得训练曲线大幅度波动而不是平稳下降。另一方面来说SGD的波动存在使训练模型跳跃至新的局部最优的可能。经过对学习速率的优化，SGD也可以达到接近批次梯度下降的效果。</p><h3 id="Mini-batch-gradient-descent"><a href="#Mini-batch-gradient-descent" class="headerlink" title="Mini-batch gradient descent"></a>Mini-batch gradient descent</h3><p>这种折中的方法继承了前两种模式的优点，在每一个epoch中对一个随机选取的小批次参数（比如50个）计算下降梯度。小批次梯度下降可以减少方差，使训练曲线更平缓同时通过现代计算机的矩阵运算优化保证了效率。这种方法是机器学习普遍采用的方法，SGD也代指使用小批次梯度下降。  </p><h2 id="基本SGD的问题"><a href="#基本SGD的问题" class="headerlink" title="基本SGD的问题"></a>基本SGD的问题</h2><p>最基本的SGD方法通常无法保证得到最佳效果：  </p><ul><li>超参数学习速率的问题，太小的学习速率导致模型收敛缓慢，过大的学习速率又导致模型在最小点来回波动甚至导致无法收敛。</li><li>使用一个学习速率变化表，提前设定一系列模型训练中学习速率的变化。但是这种方法比较死板，无法灵活适应各种情况。</li><li>还有对所有参数使用同样的更新量是不妥当的，因为数据可能比较稀疏，对于极少出现的特征需要更大的变化量。</li><li>另一个问题是可能在模型收敛过程中停滞于局部最小区域，或者是鞍状分布区。梯度无法下降。  </li></ul><h2 id="对于梯度下降的优化算法"><a href="#对于梯度下降的优化算法" class="headerlink" title="对于梯度下降的优化算法"></a>对于梯度下降的优化算法</h2><p>接下来讨论一些对于SGD的优化方法，就像是CNN架构的迭代变化，其中一些方法也有后者应用前者优势再加扩展的趋势。这里主要讨论first order优化方法。  </p><h3 id="动量-Momentum"><a href="#动量-Momentum" class="headerlink" title="动量 Momentum"></a>动量 Momentum</h3><p>传统SGD的问题在于无法越过模型训练过程中出现的山谷，这里通常是局部最优。<br>动量引入了前一步中的更新量的一部分到当前的梯度更新中，通过一个\(\gamma\)系数相乘。<br>\begin{align}<br>\begin{split}<br>v_t &amp;= \gamma v_{t-1} + \eta \nabla_\theta J( \theta)<br>\end{split}<br>\end{align}\begin{align}<br>\begin{split}<br>\theta &amp;= \theta - v_t<br>\end{split}<br>\end{align}<br>形象的来看动量使小球向梯度下降的方向逐渐加速地下滚，而在梯度变化的时候改变速度。  </p><h3 id="Nesterov-accelerated-gradient"><a href="#Nesterov-accelerated-gradient" class="headerlink" title="Nesterov accelerated gradient"></a>Nesterov accelerated gradient</h3><p>但是光靠动量推动是不够的，更聪明的方法是在向前一步时，不仅考虑到上一步的动量，也能考虑到当前下一步的梯度变化。基于这种方法的梯度更新通常有更好的表现。在公式表达中，用\(\theta - \gamma v_{t-1}\)近似下一步的移动方位，动量方法变为：\begin{align}<br>\begin{split}<br>v_t &amp;= \gamma v_{t-1} + \eta \nabla_\theta J( \theta - \gamma v_{t-1} ) \\<br>\theta &amp;= \theta - v_t<br>\end{split}<br>\end{align}<br>NAG使得梯度下降更加有预见性，在一些场景下大大提高了RNN网络的表现。  </p><h3 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h3><p>适应性（Adaptive）的梯度下降优化方法着眼于解决不同参数套用相同的更新量的问题。<br>Adagrad的变化在于维护了一个矩阵来保留每一个参数过去的梯度信息-所有过去梯度的平方和再开方，在每一个参数的更新阶段查找这个矩阵并根据结果相应的变化学习速率<br>$$\theta_{t+1} = \theta_{t} - \dfrac{\eta}{\sqrt{G_{t} + \epsilon}} \odot g_{t}$$<br>\(G_{t}\)即为过往梯度的平方和矩阵，\(g_{t}\)为每个参数的梯度矩阵。<br>Adagrad的主要问题是因为平方和的计算方法导致学习速率的分母在训练中逐渐增大，导致所能获得梯度信息越来越小，最终无法在训练。这引出了下一个优化方法。  </p><h3 id="Adadelta"><a href="#Adadelta" class="headerlink" title="Adadelta"></a>Adadelta</h3><p>Adadelta改善了Adagrad过于简单粗暴的集合全部过往梯度信息的问题，它把集合的过往梯度信息限制在了一个有限的窗口内。这种动态窗口的机制类似于Momentum动量的思想，递归方式保留过往信息。\begin{align}<br>\begin{split}<br>\Delta \theta_t &amp;= - \dfrac{RMS[\Delta \theta]_{t-1}}{RMS[g]_{t}} g_{t} \\<br>\theta_{t+1} &amp;= \theta_t + \Delta \theta_t<br>\end{split}<br>\end{align}<br>\(RMS[\Delta \theta]_{t-1}\)是过往参数信息的均方根信息。在Adadelta的梯度更新方式中已经没有学习速率，我们对于Adadelta不需要设置学习速率。</p><h3 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h3><p>同Adadelta一样，RMSprop也试图解决Adagrad的训练消失的问题。RMSprop是参数固定的Adadelta的一种情况，在集合过往梯度信息步骤使用\(\gamma\)为0.9，学习速率\(\eta\)默认设置为0.001。<br>\begin{align}<br>\begin{split}<br>E[g^2]_t &amp;= 0.9 E[g^2]_{t-1} + 0.1 g^2_t \\<br>\theta_{t+1} &amp;= \theta_{t} - \dfrac{\eta}{\sqrt{E[g^2]_t + \epsilon}} g_{t}<br>\end{split}<br>\end{align}</p><h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h3><p>Adam（Adaptive Moment Estimation）也解决了Adagrad的问题，不同的是不仅仅保留了指数减少的过往梯度均方根信息，Adam也像Momentum动量方法一样，保留了一阶的过往梯度信息。\begin{align}<br>\begin{split}<br>m_t &amp;= \beta_1 m_{t-1} + (1 - \beta_1) g_t \\<br>v_t &amp;= \beta_2 v_{t-1} + (1 - \beta_2) g_t^2<br>\end{split}<br>\end{align}<br>由于\(\beta_1\)和\(\beta_2\)经常趋近于1，于是对上式做出改变，去除偏差\begin{align}<br>\begin{split}<br>\hat{m}_t &amp;= \dfrac{m_t}{1 - \beta^t_1} \\<br>\hat{v}_t &amp;= \dfrac{v_t}{1 - \beta^t_2} \end{split}<br>\end{align}<br>Adam的更新方式为：<br>\begin{align}<br>\begin{split}<br>\theta_{t+1} = \theta_{t} - \dfrac{\eta}{\sqrt{\hat{v}_t} + \epsilon} \hat{m}_t<br>\end{split}<br>\end{align}<br>在\(\beta_1\)为0.9、\(\beta_2\)为0.999、\(\epsilon\)为\(10^{-8}\)时可以得到比其他适应性训练方法更好一些的表现。</p><h3 id="AdaMax"><a href="#AdaMax" class="headerlink" title="AdaMax"></a>AdaMax</h3><p>AdaMax是对Adam的进一步扩展，把Adam的更新参数过程中的类似于L2正则化项扩展至LN项，即名字Max的由来。</p><h3 id="Nadam"><a href="#Nadam" class="headerlink" title="Nadam"></a>Nadam</h3><p>上述讲到Adam方法中使用了Momentum思想的一阶梯度，Nadam则是结合了NAG和Adam，使用之前提到的NAG优化了Adam中的动量计算过程。</p><h3 id="AMSGrad"><a href="#AMSGrad" class="headerlink" title="AMSGrad"></a>AMSGrad</h3><p>AMSGrad源于解决Adam方法潜在的缺点，研究员发现因为Adam使用了一个滑动的指数衰减的过往梯度信息，导致训练过程中只会偶尔出现的携带巨大梯度信息的部分被平均化了。于是AMSGrad使用在参数更新过程中，使用模型训练过往的最大梯度，或者是滑动指数衰减过往梯度信息，取决于这两个值哪个更大。</p><h2 id="梯度下降优化方法选择"><a href="#梯度下降优化方法选择" class="headerlink" title="梯度下降优化方法选择"></a>梯度下降优化方法选择</h2><p>如何选择一种梯度下降的优化方法：  </p><ul><li>如果数据比较稀疏，那么使用一种适应性优化法能得到比较好的结果，使用默认的学习速率即可</li><li>总结来看，RMSprop是特例化的Adadelta，都解决了Adagrad的缺点。Adam结合了RMSprop和动量，大多数情况下选择Adam会有更好的表现。（虽然RMSprop， Adadelta和Adam的表现可能差不多）</li><li>回过头看，基础SGD+学习速率变化表也可以确保得到模型的最小点，只是需要花费大量的训练时间和可能陷落在鞍状区域和局部最小。</li><li>总结，需要很快的梯度下降来训练深层网络，则选择一种适应性梯度下降优化方法。</li></ul>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Fluent Python学习笔记（一）</title>
      <link href="/2018/09/03/fluent_python_note/"/>
      <url>/2018/09/03/fluent_python_note/</url>
      <content type="html"><![CDATA[<h3 id="Fluent-Python-学习笔记"><a href="#Fluent-Python-学习笔记" class="headerlink" title="Fluent Python 学习笔记"></a>Fluent Python 学习笔记</h3><p>从Python的数据模型上来理解Python语言，那些内置的数据模型的API为使用最地道的语言特性来构建自己的对象提供了工具。比如说有序列化、迭代器、函数、类和上下文管理器这些接口。<a id="more"></a>Python解释器在遇到特定的句法式使用特殊方法去激活一些基本的对象操作。通常以<code>__</code>开头和结尾、例如<code>__getitem__</code>比如<code>obj[key]</code>实际调用的是<code>__getitem__</code>。对于<code>my_collection[key]</code>解释器实际上会调用<code>my_collection.__getitem__(key)</code>，这些方法称之为双下方法“dunder method”。<br>一个把句子转为单词列表的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>:</span></span><br><span class="line">    quote = <span class="string">"An apple a day keeps the doctor away"</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._quote = [word <span class="keyword">for</span> word <span class="keyword">in</span> self.quote]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._quote)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._quote[position]</span><br></pre></td></tr></table></figure></p><p>因为实现了<code>__len__</code>所以可以调用len()获取我们的句子对象的长度。我们在类声明中把<code>__len__</code>的处理转交到了Python原生的数据模型List手上<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(my_quote)</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure></p><p>在我们的类中同样实现了<code>__getitem__</code>，（也是通过把<code>__getitem__</code>函数的处理转交给了List的<code>__getitem__</code>来处理）这带来了很多好处，可以原生地支持很多Python的操作<br>比如说做切片操作，甚至是利用Python的标准库，而不用重新造轮子，比如随机抽取的操作:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_quote[<span class="number">0</span>]</span><br><span class="line"><span class="string">'An'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_quote[<span class="number">4</span>:]</span><br><span class="line">[<span class="string">'keeps'</span>, <span class="string">'the'</span>, <span class="string">'doctor'</span>, <span class="string">'away'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>choice(my_quote)</span><br><span class="line"><span class="string">'keeps'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>choice(my_quote)</span><br><span class="line"><span class="string">'the'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>choice(my_quote)</span><br><span class="line"><span class="string">'away'</span></span><br></pre></td></tr></table></figure></p><p>同样的，因为实现了<code>__getitem__</code>，我们的句子同样可以迭代<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> word <span class="keyword">in</span> my_quote: </span><br><span class="line"><span class="meta">... </span>    print(word)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">An</span><br><span class="line">apple</span><br><span class="line">a</span><br><span class="line">day</span><br><span class="line">keeps</span><br><span class="line">the</span><br><span class="line">doctor</span><br><span class="line">away</span><br></pre></td></tr></table></figure></p><p>虽然我们没有实现<code>__contains__</code>方法，in运算符也会按顺序做一次迭代搜索，像是这样:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'apple'</span> <span class="keyword">in</span> my_quote</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'banana'</span> <span class="keyword">in</span> my_quote</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><p>也可以对句子中的单词做首字母降序排序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(my_quote)</span><br><span class="line">[<span class="string">'An'</span>, <span class="string">'a'</span>, <span class="string">'apple'</span>, <span class="string">'away'</span>, <span class="string">'day'</span>, <span class="string">'doctor'</span>, <span class="string">'keeps'</span>, <span class="string">'the'</span>]</span><br></pre></td></tr></table></figure></p><p>通过把<code>__len__</code>和<code>__getitem__</code>的具体实现代理给<code>self._quote</code>这个Python List对象使我们的<code>Qoute</code>类就像是Python自由的序列数据雷翔一样，应用Python的核心语言特性也轻而易举，同样适用于标准库中的函数。  </p><p>还有一些其他的Python类特殊方法可以使编程更加优雅，比如对自己创建的向量类<code>Vector</code>做加法、向量乘法、求绝对值、求布尔值以及如何用字符串的形式来表达。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0</span>, y=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(%r, %r)'</span> % (self.x, self.y)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x, self.y)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar)</span><br></pre></td></tr></table></figure></p><p>对创建的Vector类进行实例化，对两个Vector实例做相加运算，调用<code>abs(v2)</code>计算向量的模等。可以发现Vector类的字符串表达也被定义了，在调用以字符串的形式表达时能正确的输出<code>&#39;Vector(%r, %r)&#39; % (self.x, self.y)</code>这样的形式。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v2 = Vector(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v2</span><br><span class="line">Vector(<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(v2)</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 * <span class="number">3</span></span><br><span class="line">Vector(<span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(v1)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><p><a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">参考Python语言手册中的Data Model</a>总结Python中的特殊方法，共83个特殊方法的名字，其中47个用于实现算术运算、位运算和比较操作:  </p><table><thead><tr><th>类别</th><th>方法名</th></tr></thead><tbody><tr><td>字符串/字节序列表示形式</td><td><code>__repr__、__str__、__format__、__bytes__</code></td></tr><tr><td>数值转换</td><td><code>__abs__、__bool__、__complex__、__int__、__float__、__hash__、__index__</code></td></tr><tr><td>集合模拟</td><td><code>__len__、__getitem__、__setitem__、__delitem__、__contains__</code></td></tr><tr><td>迭代枚举</td><td><code>__iter__、__reversed__、__next__</code></td></tr><tr><td>可调用模拟</td><td><code>__call__</code></td></tr><tr><td>上下文管理</td><td><code>__enter__、__exit__</code></td></tr><tr><td>实例创建和销毁</td><td><code>__new__、__init__、__del__</code></td></tr><tr><td>属性管理</td><td><code>__getattr__、__getattribute__、__setattr__、__delattr__、__dir__</code></td></tr><tr><td>属性描述符</td><td><code>__get__、__set__、__delete__</code></td></tr><tr><td>跟类相关的服务</td><td><code>__prepare__、__instancecheck__、__subclasscheck__</code></td></tr></tbody></table><p>跟运算符相关的特殊方法:  </p><table><thead><tr><th>类别</th><th>方法名和对应的运算符</th></tr></thead><tbody><tr><td>一元运算符</td><td><code>__neg__ -、__pos__ +、__abs__ abs()</code></td></tr><tr><td>众多比较运算符</td><td><code>__lt__ &lt;、__le__ &lt;=、__eq__ ==、__ne__ !=、__gt__ &gt;、__ge__ &gt;=</code></td></tr><tr><td>算术运算符</td><td><code>__add__ +、__sub__ -、__mul__ *、__truediv__ /、__floordiv__ //、__mod__ %、__divmod__ divmod()、__pow__ ** 或pow()、__round__ round()</code></td></tr><tr><td>反向运算运算符</td><td><code>__radd__、__rsub__、__rmul__、__rtruediv__、__rfloordiv__、__rmod__、__rdivmod__、__rpow__</code></td></tr><tr><td>增量赋值算术运算符</td><td><code>__iadd__、__isub__、__imul__、__itruediv__、__ifloordiv__、__imod__、__ipow__</code></td></tr><tr><td>位运算符</td><td><code>__invert__ ~、__lshift__ &lt;&lt;、__rshift__ &gt;&gt;、__and__ &amp;、__or__ 、__xor__ ^</code></td></tr><tr><td>反向位运算符</td><td><code>__rlshift__、__rrshift__、__rand__、__rxor__、__ror__</code></td></tr><tr><td>增量赋值位运算符</td><td><code>__ilshift__、__irshift__、__iand__、__ixor__、__ior__</code></td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>博客施工中---</title>
      <link href="/2018/08/12/construction/"/>
      <url>/2018/08/12/construction/</url>
      <content type="html"><![CDATA[<!-- ![under_construction](https://github.com/magiczjp123/my_blog/raw/master/construction/under_construction.jpg) --><p><img src="https://github.com/magiczjp123/my_blog_imgs/raw/master/construction/under_construction.jpg" width="400" hegiht="240" align="center"><br><a id="more"></a><br>博客施工中—</p>]]></content>
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记录工作</title>
      <link href="/2018/08/08/related/"/>
      <url>/2018/08/08/related/</url>
      <content type="html"><![CDATA[<p>吉迈机器人资料汇总<br><a href="http://www.boocax.com/col.jsp?id=104" title="资料" target="_blank" rel="noopener">北京布科思技术支持资料网站</a><br><a id="more"></a></p><h2 id="机器人流程化配置方法（分步）"><a href="#机器人流程化配置方法（分步）" class="headerlink" title="机器人流程化配置方法（分步）"></a>机器人流程化配置方法（分步）</h2><h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a><strong>配置网络</strong></h3><h4 id="布科思的主机出厂配置默认连接的WIFI网络是："><a href="#布科思的主机出厂配置默认连接的WIFI网络是：" class="headerlink" title="布科思的主机出厂配置默认连接的WIFI网络是："></a>布科思的主机出厂配置默认连接的WIFI网络是：</h4><blockquote><p>网络名称：robot_test<br>网络密码：robot123</p></blockquote><h4 id="在有这样设置的WIFI无线路由器的情况下会自动连接。如果需要设置成自动连接其他的WIFI网络，可以通过两种方法："><a href="#在有这样设置的WIFI无线路由器的情况下会自动连接。如果需要设置成自动连接其他的WIFI网络，可以通过两种方法：" class="headerlink" title="在有这样设置的WIFI无线路由器的情况下会自动连接。如果需要设置成自动连接其他的WIFI网络，可以通过两种方法："></a>在有这样设置的WIFI无线路由器的情况下会自动连接。<strong><em>如果需要设置成自动连接其他的WIFI网络</em></strong>，可以通过两种方法：</h4><ol><li><p>通过ssh远程登录布科思主机修改，注意必须确保和布科思主机在同一个WIFI网络下。ssh命令   </p><p> <code>ssh boocax@</code><del><code>192.168.1.144</code></del><br> <code>boocax@</code><del><code>192.168.1.144</code></del><code>&#39;s password:</code></p><p> 替换划掉的部分为实际的局域网内布科思主机地址。主机地址可以通过window客户端或者其他形式接收局域网内的UDP广播解析得到。ssh远程登录密码为<code>robot123</code>，这也是布科思主机的<code>root</code>密码。<br> 登录布科思主机后可以修改位于主目录下<code>data</code>目录的<code>wlan.conf</code>文件 </p><p> <code>boocax@boocax-robot:~$ sudo nano data/wlan.conf</code>   </p><p> 把<code>ssid</code>和<code>password</code>分别改为其他的网络名称和WIFI密码    </p><p> <code>ssid=(网路名称)</code><br> <code>password=(WIFI密码)</code>      </p><p> 设置完WIFI后重启布科思就会自动连接新网络</p></li><li><p>用VGA视频传输线连接主机VGA输出到电脑屏幕。修改<code>wlan.conf</code>的方法同上。</p></li></ol><h3 id="加载消毒程序"><a href="#加载消毒程序" class="headerlink" title="加载消毒程序"></a><strong>加载消毒程序</strong></h3><h4 id="在布科思主机上需要新增额外的消毒程序ROS包。分下面几步："><a href="#在布科思主机上需要新增额外的消毒程序ROS包。分下面几步：" class="headerlink" title="在布科思主机上需要新增额外的消毒程序ROS包。分下面几步："></a>在布科思主机上需要新增额外的消毒程序ROS包。分下面几步：</h4><ol><li><p>找到并打开布科思的<code>app.launch</code>文件：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boocax@boocax-robot:~$ sudo nano roswork/src/boocax_base/launch/app.launch</span><br></pre></td></tr></table></figure><p> 在文档中加入以下：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jm launch file  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">"jm_operation"</span> <span class="attr">type</span>=<span class="string">"jm_disinfect.py"</span> <span class="attr">name</span>=<span class="string">"jm_disinfect"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p> 这样布科思主机自启动文件就可以自动打开消毒程序了。</p></li><li><p>复制<code>jm_operation</code>文件夹至<code>roswork</code>下的<code>src</code>文件夹中。</p></li><li><p>重启主机，消毒程序随自启动运行。<code>rosnode list</code>可以看到<code>/jm_disinfect</code>的节点，即为消毒程序。</p></li></ol><h3 id="配置机器人运动参数"><a href="#配置机器人运动参数" class="headerlink" title="配置机器人运动参数"></a><strong>配置机器人运动参数</strong></h3><h4 id="参考布科思支持文档06配置手册"><a href="#参考布科思支持文档06配置手册" class="headerlink" title="参考布科思支持文档06配置手册"></a>参考布科思支持文档06配置手册</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config</span></span><br><span class="line">have_visual = 1</span><br><span class="line"><span class="comment"># server_ip = 192.168.0.37</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># UWB</span></span><br><span class="line">uwb_port = /dev/ttyS3</span><br><span class="line">uwb_baudrate = 9600</span><br><span class="line">uwb_x_pos = 0.0</span><br><span class="line">uwb_y_pos = 0.0</span><br><span class="line"><span class="comment"># uwb_tag = 46 1 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运动底盘</span></span><br><span class="line">base_baudrate = 9600</span><br><span class="line">base_port = /dev/ttyS2</span><br><span class="line">base_link_format = 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># APP</span></span><br><span class="line">send_custom_to_app = 1</span><br><span class="line">send_custom_to_base = 1</span><br><span class="line">app_use_serial = 1</span><br><span class="line">app_baudrate = 9600</span><br><span class="line">app_port = /dev/ttyS0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 里程计</span></span><br><span class="line">have_odom = 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激光</span></span><br><span class="line"><span class="comment"># 激光相对于机器人中心的坐标变换，前三位分别表示 x，y，z 轴的偏移量，单位米，后三位 表示角度变换 roll，pitch，yaw，单位弧度</span></span><br><span class="line">laser_tf = 0.215, 0, 0.30, 0, 0, 0</span><br><span class="line">scan_filtered = 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 机器人轮廓</span></span><br><span class="line"><span class="comment"># 圆形机器人设置robot_radius和pole_distance，非圆形机器人设置footprint</span></span><br><span class="line"><span class="comment">#robot_radius = 0.25</span></span><br><span class="line"><span class="comment">#pole_distance = 0.3</span></span><br><span class="line">footprint = [[0.225,-0.18],[0.225,0.18],[-0.225,0.18],[-0.225,-0.18]]</span><br><span class="line"><span class="comment">#footprint = [[0.265,-0.18],[0.265,0.18],[-0.265,0.18],[-0.265,-0.18]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#feasibility_check_dist = 0.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#轮轴距，轮半径，电机减速比</span></span><br><span class="line">width_wheel = 0.295</span><br><span class="line">radius_wheel = 0.084</span><br><span class="line">reduction_gear_ratio = 0.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 超声波</span></span><br><span class="line">have_sonar = 0</span><br><span class="line">sonar_fliter = 0</span><br><span class="line">sonar_zero_inver = 2.0</span><br><span class="line"><span class="comment">#sonar data: 安装角度(度数)，安装距离(米)，最小距离(米)，最大距离(米)，视角（度数），朝向角度（度数）</span></span><br><span class="line">sonar3 = 337.5,0.249,0.01,0.45,15,0</span><br><span class="line">sonar1 = 22.5,0.249,0.01,0.45,15,0</span><br><span class="line">sonar2 = 0,0.15,0.01,0.45,15,0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局路径搜索参数设置</span></span><br><span class="line">inflation = 0.4</span><br><span class="line">inflation_weight = 1.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导航参数，不建议修改</span></span><br><span class="line">map_publish_frequency = 0</span><br><span class="line"><span class="comment">#local_window = 4</span></span><br><span class="line"><span class="comment">#control_frequency = 10</span></span><br><span class="line"><span class="comment">#map_update_frequency = 5</span></span><br><span class="line"><span class="comment">#safe_cmd_dist = 0.15</span></span><br><span class="line"><span class="comment">#search_goal_tolerance = 0.0</span></span><br><span class="line"><span class="comment">#search_path_tolerance = 0.0</span></span><br><span class="line"><span class="comment">#path_search_patience = 0.0</span></span><br><span class="line">allow_cancel_patience = 60</span><br><span class="line">report_cancel_patience = 30</span><br><span class="line"></span><br><span class="line">ui_laser_timer = 2.0</span><br><span class="line">ui_uwb_timer = 0.2</span><br><span class="line">ui_sonar_timer = 0.2</span><br><span class="line"><span class="comment">#auto_poweron_time = 0</span></span><br><span class="line">poweroff_delay_time = 20</span><br></pre></td></tr></table></figure><h2 id="机器人总结"><a href="#机器人总结" class="headerlink" title="机器人总结"></a><strong>机器人总结</strong></h2><h3 id="问题总结："><a href="#问题总结：" class="headerlink" title="问题总结："></a>问题总结：</h3><ol><li>机器人导航使用的深度相机面对墙壁丢帧，影响导航性能</li><li>机器人的相对位置link设置基于运动中心</li><li>导航通过窄道边缘转弯容易擦碰</li><li>导航正前方有障碍物会导航失败</li><li>确认摄像头型号</li></ol>]]></content>
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用hexo部署在Github上部署静态网页总结</title>
      <link href="/2018/08/06/first-post/"/>
      <url>/2018/08/06/first-post/</url>
      <content type="html"><![CDATA[<p> 这篇文章主要记录下使用hexo在Github上部署静态网页的过程<br><a id="more"></a></p><h3 id="第一步、在自己的Github网站上建立新的repo、命名为username-github-io，这样就可以访问这个地址，发现已经是托管于Github的网页了。"><a href="#第一步、在自己的Github网站上建立新的repo、命名为username-github-io，这样就可以访问这个地址，发现已经是托管于Github的网页了。" class="headerlink" title="第一步、在自己的Github网站上建立新的repo、命名为username.github.io，这样就可以访问这个地址，发现已经是托管于Github的网页了。"></a>第一步、在自己的Github网站上建立新的repo、命名为<code>username.github.io</code>，这样就可以访问这个地址，发现已经是托管于Github的网页了。</h3><h3 id="第二步、在本地安装hexo，在网上搜索Ubuntu安装hexo可以发现不少详细的教程："><a href="#第二步、在本地安装hexo，在网上搜索Ubuntu安装hexo可以发现不少详细的教程：" class="headerlink" title="第二步、在本地安装hexo，在网上搜索Ubuntu安装hexo可以发现不少详细的教程："></a>第二步、在本地安装hexo，在网上搜索Ubuntu安装hexo可以发现不少详细的教程：</h3><blockquote><p><a href="https://www.jianshu.com/p/a3ab83dba041" target="_blank" rel="noopener">Ubuntu平台下通过Hexo在Github上搭建博客教程(一)</a><br><a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa#xiu-gai-zhu-ti" target="_blank" rel="noopener">使用hexo+github搭建免费个人博客详细教程</a><br><a href="https://gist.github.com/btfak/18938572f5df000ebe06fbd1872e4e39" target="_blank" rel="noopener">How to use Hexo and deploy to GitHub Pages</a></p></blockquote><h3 id="第三步、配置hexo，在Github上部署静态网页需要在本地hexo主目录下的-config-yml文件中配置hexo-deploy建立本地与自己的Github-repo的关联，之后就可以直接命令行部署到Github上了。"><a href="#第三步、配置hexo，在Github上部署静态网页需要在本地hexo主目录下的-config-yml文件中配置hexo-deploy建立本地与自己的Github-repo的关联，之后就可以直接命令行部署到Github上了。" class="headerlink" title="第三步、配置hexo，在Github上部署静态网页需要在本地hexo主目录下的_config.yml文件中配置hexo deploy建立本地与自己的Github repo的关联，之后就可以直接命令行部署到Github上了。"></a>第三步、配置hexo，在Github上部署静态网页需要在本地hexo主目录下的_config.yml文件中配置<code>hexo deploy</code>建立本地与自己的Github repo的关联，之后就可以直接命令行部署到Github上了。</h3><h3 id="第四步、配置hexo-theme，安装好hexo使用hexo-generate生成网页后发现使用的是hexo自带的landscape主题。为了个性化可以在网上寻找由其他人分享的各种各样的主题。在下载的主题的目录下的-config-yml文件里可以配置像是评论系统、搜索、tag、分类等等。"><a href="#第四步、配置hexo-theme，安装好hexo使用hexo-generate生成网页后发现使用的是hexo自带的landscape主题。为了个性化可以在网上寻找由其他人分享的各种各样的主题。在下载的主题的目录下的-config-yml文件里可以配置像是评论系统、搜索、tag、分类等等。" class="headerlink" title="第四步、配置hexo theme，安装好hexo使用hexo generate生成网页后发现使用的是hexo自带的landscape主题。为了个性化可以在网上寻找由其他人分享的各种各样的主题。在下载的主题的目录下的_config.yml文件里可以配置像是评论系统、搜索、tag、分类等等。"></a>第四步、配置hexo theme，安装好hexo使用<code>hexo generate</code>生成网页后发现使用的是hexo自带的landscape主题。为了个性化可以在网上寻找由其他人分享的各种各样的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>。在下载的主题的目录下的_config.yml文件里可以配置像是评论系统、搜索、tag、分类等等。</h3><h3 id="这个博客使用的是AlynxZhou-github制作的hexo-theme-aria，界面简洁明了。"><a href="#这个博客使用的是AlynxZhou-github制作的hexo-theme-aria，界面简洁明了。" class="headerlink" title="这个博客使用的是AlynxZhou@github制作的hexo-theme-aria，界面简洁明了。"></a>这个博客使用的是AlynxZhou@github制作的<a href="https://github.com/AlynxZhou/hexo-theme-aria/blob/master/README.zh_CN.md" target="_blank" rel="noopener">hexo-theme-aria</a>，界面简洁明了。</h3><h3 id="这篇文章主要是方便自己记录下部署Github博客的过程，hexo是一个很棒的工具，还有很多地方需要学习。"><a href="#这篇文章主要是方便自己记录下部署Github博客的过程，hexo是一个很棒的工具，还有很多地方需要学习。" class="headerlink" title="这篇文章主要是方便自己记录下部署Github博客的过程，hexo是一个很棒的工具，还有很多地方需要学习。"></a>这篇文章主要是方便自己记录下部署Github博客的过程，hexo是一个很棒的工具，还有很多地方需要学习。</h3>]]></content>
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
